// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.IO;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace MyGenerator
{
    /// <summary>
    /// </summary>
    [Generator]
    public class TypeCatalogGenerator : ISourceGenerator
    {
        /// <summary>
        /// Summary:
        ///     Called to perform source generation. A generator can use the context to add source
        ///     files via the Microsoft.CodeAnalysis.SourceGeneratorContext.AddSource(System.String,Microsoft.CodeAnalysis.Text.SourceText)
        ///     method.
        ///
        /// Parameters:
        ///   context:
        ///     The Microsoft.CodeAnalysis.SourceGeneratorContext to add source to
        /// </summary>
        public void Execute(GeneratorExecutionContext context)
        {
            // TODO - actual source generator goes here!
            var assemblies = context.Compilation.References.ToArray();
            MetadataReference b1 = assemblies[0];
            var s = $"{assemblies.Select(a => a.Display).Aggregate("", (a, b) => a + Environment.NewLine + b)}";

            using var outputFile = new StreamWriter($"c:/tmp/q1_{DateTime.Now:yyyyMMddHHmmss}.txt");
            outputFile.WriteLine(s);

            // Get the array of runtime assemblies.
            string[] runtimeAssemblies = Directory.GetFiles(System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");

            // Create the list of assembly paths consisting of runtime assemblies and the inspected assembly.
            var paths = new List<string>(runtimeAssemblies);
            var resolver = new PathAssemblyResolver(paths);

            Dictionary<string, TypeMetadata> typeNameToAssemblyMap = new Dictionary<string, TypeMetadata>(StringComparer.OrdinalIgnoreCase);

            using var mlc = new MetadataLoadContext(resolver);
            foreach (var assemblyMetaDataReference in assemblies)
            {

                try
                {
                    Assembly assembly = mlc.LoadFromAssemblyPath(assemblyMetaDataReference.Display);
                    var types = assembly.GetExportedTypes();

                    foreach (var type in types)
                    {
                        var isTypeObsolete = CustomAttributeData.GetCustomAttributes(type).Count > 0;
                        // type.GetCustomAttributes(typeof(System.ObsoleteAttribute), true).Length > 0;
                        typeNameToAssemblyMap.Add(type.FullName, new TypeMetadata(assembly.FullName, isTypeObsolete));
                    }
                }
                catch (FileLoadException)
                { }
            }

            var result = WritePowerShellAssemblyLoadContextPartialClass(typeNameToAssemblyMap);

            context.AddSource("qqqq.cs", result);
        }

        /// <summary>
        /// Summary:
        ///     Called before generation occurs. A generator can use the context to register
        ///     callbacks required to perform generation.
        ///
        /// Parameters:
        ///   context:
        ///     The Microsoft.CodeAnalysis.InitializationContext to register callbacks on
        /// </summary>
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this one
        }

        /// <summary>
        /// Generate the CSharp source code that initialize the type catalog.
        /// </summary>
        private static string WritePowerShellAssemblyLoadContextPartialClass(Dictionary<string, TypeMetadata> typeNameToAssemblyMap)
        {
            const string SourceFormat = "{2}                {{\"{0}\", \"{1}\"}},";
            const string SourceHead = @"//
// This file is auto-generated by TypeCatalogGen.exe during build of Microsoft.PowerShell.CoreCLR.AssemblyLoadContext.dll.
// This file will be compiled into Microsoft.PowerShell.CoreCLR.AssemblyLoadContext.dll.
//
// In CoreCLR, there is no way to get all loaded TPA assemblies (.NET Framework Assemblies). In order to get type based on type
// name, powershell needs to know what .NET types are available and in which TPA assemblies. So we have to generate this type
// catalog based on the reference assemblies of .NET Core.
//
using System.Collections.Generic;

namespace System.Management.Automation
{{
    internal partial class PowerShellAssemblyLoadContext
    {{
        private Dictionary<string, string> InitializeTypeCatalog()
        {{
            return new Dictionary<string, string>({0}, StringComparer.OrdinalIgnoreCase) {{";
            const string SourceEnd = @"
            };
        }
    }
}
";

            StringBuilder sourceCode = new StringBuilder(string.Format(CultureInfo.InvariantCulture, SourceHead, typeNameToAssemblyMap.Count));
            foreach (KeyValuePair<string, TypeMetadata> pair in typeNameToAssemblyMap)
            {
                sourceCode.Append(string.Format(CultureInfo.InvariantCulture, SourceFormat, pair.Key, pair.Value.AssemblyName, Environment.NewLine));
            }

            sourceCode.Append(SourceEnd);

            return sourceCode.ToString();
        }

        /// <summary>
        /// Helper class to keep the metadata of a type.
        /// </summary>
        private class TypeMetadata
        {
            internal readonly string AssemblyName;
            internal readonly bool IsObsolete;
            internal TypeMetadata(string assemblyName, bool isTypeObsolete)
            {
                this.AssemblyName = assemblyName;
                this.IsObsolete = isTypeObsolete;
            }
        }
    }
}
